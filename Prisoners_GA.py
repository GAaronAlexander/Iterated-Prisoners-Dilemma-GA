import numpy as np
import csv
from pathlib import Path
from IPD_functions import *
from GA_functions import *


def run_prisoners_ga(seed = None,
                     data_folder = None,
                     initial_population = None,
                     start_gen = 0,
                     max_gen = 100,
                     population_size = 20,
                     prob_crossover = 0.8,
                     prob_mutation = 0.001,
                     selection_type = 'tournament_2',
                     crossover_type = 'onepoint',
                     run_description = 'std'
                    ):
  """Run the GA algorithm.

  Typical run: run_prisoners_ga(seed = 0, data_folder = Path('output_data/'),
                                max_gen = 20000).

  Arguments:
    seed (int): Nonnegative seed for the random number generator, to provide
                reproducible results. Can be set to None for random seed.

    initial_population: Can be any of:
                None (creates random population)
                a list of strategies, as strings
                a single strategy to be duplicated, as a string

    data_folder should be a Path object, for example created with the line:
            Path('output_data/01_01_2020/')
        (always use forward slashes ('/') in the string). Will use current
        directory if set to None.

    selection_type (string): Set to 'weighted' for selection to be weighted by
        by fitness, or 'tournament_2', 'tournament_3', etc. for tournament
        selection using tournaments of the given size.

    crossover_type (string): Set to 'onepoint' or 'random'.
  
    population_size (int): Size of each generation. Must be even (for
        crossover). Ignored if initial_population is given as a list.

    prob_crossover (float): Probability. For each pair of strategies, has a
        prob_crossover chance to perform a crossover opperation on that pair.

    prob_mutation (float): Probability that each bit is flipped.
                      For general GA's, 1/DIM recommended, though this may not
                      apply here.

    run_description (string): This will appear at the beginning of the name of
        the folder created for new data. Used to indicate anything unusual
        about the run not captured in the folder name (see "File
        organization"). For example, if using an initial population of
        tit-for-tat strategies, this could be 'Init_tft'.
       
  Future Attributes:
    num_players (int): Number of players in each match. (Currently always 2.)

    history_length (int): A player's memory span. Each strategy is based on
        considering what each player did the last history_length (or fewer,
        if less rounds have been played in the match so far) rounds.
        (Currently always 3.)

    num_rounds (int): Number of times prisoner's dilemma is played each match.
         (Currently always 64.)

    cost (int): The cost a player pays each time they cooperate.
         (Currently always 2.)

    benefit (int): The benefit other players receive each time a player
        cooperates. (Currently always 5.)

    continue_run_name (string): (Will) continue the run located at the Path  ##################
            data_folder / continue_run_name
        Automatically sets initial_population to the last computed generation
        and sets start_gen appropriately. Some code to use:
            # Grabs data from previous run
            with open(data_folder / continue_run_name, 'r') as F:
             reader = csv.reader(F)
             for row in reader:
               P.append(row[0])

  Returns:
    Path to the folder containing results. See "File organization" for details;
    the return value is the path <data_folder>/<run name>/

  File organization:
    <data_folder>/                    Specified by data_folder argument.
      <run name>/                     Unique name of folder generated by code
                                      (see below).
        parameter_summary.csv         Records full values of all arguments.
        raw_output/                   Contains results from this function.
          gen_0.csv
          gen_1.csv
          ...
        results_summary.csv           If process_output(...) is run after this
                                        function, processed data stored here.

    <run name> is based on arguments to this function. For example,
    run_prisoners_ga(seed = 13) gives a folder name of:
        std_SEED_13_POP_20_CR_op80_MUT_10_SEL_t2_PL_2_HIS_3_RDS_64_C_2_B_5
    The parameters initial_population, start_gen, and max_gen are not
    reflected here (use run_description note non-random initial populations).
  """
  assert(population_size % 2 == 0)
  if data_folder is None:
    data_folder = Path('')
  if (seed):
    np.random.seed(seed)

  # Initialize selection and crossover types.
  if selection_type == 'weighted':
    selection_function = weighted_fitness_selection
    selection_type_code = 'wt'
  elif selection_type[ : len('tournament_')] == 'tournament_':
    tournament_size = int(selection_type[len('tournament_') : ])
    selection_function = lambda P, scores: tournament_selection(P, scores,
        tournament_size)
    selection_type_code = 't' + str(tournament_size)
  if crossover_type == 'onepoint':
    crossover_pair_function = crossover_pair_onepoint
    cross_type_code = 'op'
  elif crossover_type == 'random':
    crossover_pair_function = crossover_pair_random
    cross_type_code = 'rn'

  # Generate a string for folder name that encodes input parameters.
  # The hard-coded numbers are current fixed entries for future arguments
  # num_players, history_length, num_rounds, cost, and benefit.
  run_name = [run_description,
              'SEED', str(seed),
              'PL', '2',
              'HIS', '3',
              'RDS', '64',
              'POP', str(population_size),
              'CR', cross_type_code + str(round(prob_crossover*100)),
              'MUT', str(round(1/prob_mutation)),
              'SEL', selection_type_code,
              'C', '2', 'B', '5']
  run_name = '_'.join(run_name)

  # Create the folder that contains all data for this particular run.
  run_folder = data_folder / run_name
  run_folder.mkdir()        # Will fail if folder name has already been taken.

  # Records full values of all arguments.
  arg_names = ['seed', 'num_players', 'history_length', 'num_rounds',
               'initial_population', 'population_size', 'prob_crossover',
               'prob_mutation', 'selection_type', 'crossover_type',
               'cost', 'benefit']
  arg_values = [seed, 2, 3, 64,
                initial_population, population_size, prob_crossover,
                prob_mutation, selection_type, crossover_type,
                2, 5]
  with open(run_folder / 'parameter_summary.csv', 'w+') as csv_file:  
    csv_writer = csv.writer(csv_file) 
    csv_writer.writerow(arg_names)
    csv_writer.writerow(arg_values)

  # Create sub-directory for the raw output (the main output of this function).
  raw_output_folder = run_folder / 'raw_output'
  raw_output_folder.mkdir()

  # Initialize the population.
  if initial_population:
    if type(initial_population) == list:
      P = initial_population
      population_size = len(P)
    else:
      # initial_population is a single strategy to be duplicated.
      P = [initial_population]*population_size
  else:
    # Generate random initial population (a random array of 20 x 85 random
    # 0's and 1's)
    dim = 85  # dimension of decision variable space
    P_2d = np.random.randint(0, 2, (population_size, dim))
    P_2d = P_2d.tolist()
    # Convert to binary strings that are dim characters long.
    P = [0]*population_size
    for i in range(population_size):
      for j in range(dim):
        P_2d[i][j] = str(P_2d[i][j])
      P[i] = ''.join(P_2d[i])

  # Create slots to store the result of each generation
  results = [[0] * 2 for i in range(population_size)]

  # Run the algorithm
  for gen in range(start_gen, max_gen):
    # Evaluate.
    f = total_scores(P)

    # Save result.
    for i in range(population_size):
      results[i][0] = P[i]
      results[i][1] = f[i]
    with open(raw_output_folder / ('gen_%s.csv'%(gen)), 'w+', newline = '\n') as csv_file:  
      csv_writer = csv.writer(csv_file) 
      csv_writer.writerows(results)

    # Select parents from population.
    P = selection_function(P, f)

    # For each pair of strategies from P, has a prob_crossover chance to
    # perform a crossover opperation on that pair using
    # crossover_pair_function.
    P = crossover(P, crossover_pair_function, prob_crossover)

    # For each bit of each strategy from P, has a prob_mutation chance to
    # flip that bit.
    P = mutation(P, prob_mutation)

  return run_folder
